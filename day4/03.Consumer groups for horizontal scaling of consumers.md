## Kafka Consumer Group Basics

Kafka distributes data among consumers **at the partition level**.

- A **consumer group** is a logical set of consumers that share the work of reading from a topic.
- Kafka ensures that **each partition is consumed by only one consumer within a group** at a time.

So, if a topic has **N partitions**, then **at most N consumers** in a group can be active and reading data concurrently.

## Example: Matching Consumers and Partitions

Let’s take a simple example.

| Topic          | Number of Partitions | Number of Consumers (in group) | What Happens                                             |
| -------------- | -------------------- | ------------------------------ | -------------------------------------------------------- |
| `transactions` | 3                    | 3                              | Each consumer gets one partition (balanced distribution) |
| `transactions` | 3                    | 2                              | One consumer gets two partitions; the other gets one     |
| `transactions` | 3                    | 4                              | One consumer remains idle (no partitions assigned)       |

## When Consumers > Partitions

If you have **more consumers than partitions** in a group:

- The **extra consumers will remain idle**.
- Kafka will **not assign any partitions** to them.
- They will still be **part of the group**, but won’t receive any data.

You can verify this with a command like:

```bash
kafka-consumer-groups.sh \
  --describe \
  --group txn-processor-group \
  --bootstrap-server localhost:9092
```

Example output:

```
TOPIC           PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG  CONSUMER-ID  HOST  CLIENT-ID
transactions    0          1000            1000            0    consumer-1   /10.0.0.1   consumer-1
transactions    1          1000            1000            0    consumer-2   /10.0.0.2   consumer-2
transactions    2          1000            1000            0    consumer-3   /10.0.0.3   consumer-3
```

Even if `consumer-4` is running in the same group, it won’t appear here — it’s **unassigned**.

## Why Kafka Does This

Kafka’s **unit of parallelism** is the partition.
There’s no smaller unit than that.

Since a single partition can be consumed by only one consumer in a group, once all partitions are assigned, **adding more consumers doesn’t increase parallelism**.

This design ensures:

- **No message duplication** within a consumer group
- **Order guarantees** per partition are preserved

## Implications for Scaling Strategy

Here’s what this means for your scaling decisions:

### Case 1: Consumers < Partitions

- Some consumers handle multiple partitions.
- Throughput might be limited by those consumers’ processing capacity.
- You can scale horizontally (add consumers) to balance the load.

### Case 2: Consumers = Partitions

- Perfect utilization.
- Each consumer gets one partition — ideal balance.

### Case 3: Consumers > Partitions

- Extra consumers remain idle.
- Adding consumers does **not improve performance**.

## 6. Example Visualization

For a topic with **3 partitions (P0, P1, P2)**:

**Case A: 3 Consumers**

```
C1 -> P0
C2 -> P1
C3 -> P2
```

**Case B: 2 Consumers**

```
C1 -> P0, P2
C2 -> P1
```

**Case C: 4 Consumers**

```
C1 -> P0
C2 -> P1
C3 -> P2
C4 -> (idle)
```

Kafka’s group coordinator automatically handles these assignments during a **rebalance**.

## 7. Best Practices

1. **Match partitions to desired parallelism.**
   If you expect 10 parallel consumers, design your topic with at least 10 partitions.

2. **Avoid unnecessary consumers.**
   Extra consumers increase memory and network overhead but don’t add throughput.

3. **Consider scaling partitions instead.**
   If you’ve maxed out consumer count but need more parallelism, increase topic partitions.

   ```bash
   kafka-topics.sh --alter --topic transactions --partitions 12 --bootstrap-server localhost:9092
   ```

4. **Monitor consumer lag and partition assignment.**
   Tools like Prometheus or Kafka UI can show unassigned consumers and lagging partitions.

## Summary

| Scenario               | Description                               | Effect                            |
| ---------------------- | ----------------------------------------- | --------------------------------- |
| Consumers < Partitions | Some consumers handle multiple partitions | Utilization OK, lower parallelism |
| Consumers = Partitions | One-to-one mapping                        | Ideal balance                     |
| Consumers > Partitions | Extra consumers remain idle               | No performance gain               |

**In short:**
When there are **more consumers than partitions**, the extra consumers **won’t do any work**.
Kafka’s design enforces this to maintain message ordering and consistency.
