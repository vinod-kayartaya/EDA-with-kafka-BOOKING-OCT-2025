# Kafka Security Architecture

Apache Kafka’s security framework is built on three main pillars:

| Security Layer                             | Purpose                                                     | Implemented Using                                                           |
| ------------------------------------------ | ----------------------------------------------------------- | --------------------------------------------------------------------------- |
| **Encryption (Confidentiality)**           | Ensures no one can read or tamper with messages in transit. | **TLS (Transport Layer Security)**                                          |
| **Authentication (Identity Verification)** | Confirms _who_ is connecting — both clients and brokers.    | **SASL (Simple Authentication and Security Layer)** using **SCRAM-SHA-512** |
| **Authorization (Access Control)**         | Controls _what actions_ an authenticated user can perform.  | **ACLs (Access Control Lists)** stored in **Zookeeper**                     |

## 1. Encryption — Transport Layer Security (TLS)

**TLS (Transport Layer Security)** is used to encrypt data moving between Kafka clients and brokers.

Without TLS, Kafka sends messages (and credentials) in plaintext. Anyone intercepting the network traffic could read or modify them.

### How TLS Works in Kafka

1. The Kafka broker has a **private key** and a **public certificate** signed by a trusted **Certificate Authority (CA)**.
2. When a client connects, the broker presents this certificate.
3. The client verifies that:

   - The certificate is signed by a trusted CA (e.g., our `ca.crt`).
   - The hostname matches the certificate’s Common Name (CN).

4. A **secure session** (TLS handshake) is established, encrypting all further communication.

**Analogy:**
TLS is like sealing an envelope — even if someone intercepts the letter, they can’t read the message.

## 2. Authentication — SASL/SCRAM-SHA-512

**SASL (Simple Authentication and Security Layer)** provides a pluggable framework for authentication.
Kafka supports several mechanisms — **PLAIN**, **SCRAM**, **GSSAPI (Kerberos)**, and **OAUTHBEARER**.

Here we used **SCRAM (Salted Challenge Response Authentication Mechanism)** with **SHA-512** hashing.

### How SASL/SCRAM Works

1. The user (`admin`) and its password (`Welcome#123`) are stored securely as **SCRAM credentials** in Zookeeper.
2. When a client connects, Kafka and the client exchange a **challenge-response** handshake:

   - The broker sends a random salt and iteration count.
   - The client uses these with its password to compute a hash.
   - The broker compares this derived hash with the stored credential.

3. If the computed values match, the client is authenticated.

**Why SCRAM is secure:**

- The actual password is _never_ sent over the network.
- Even if someone captures the packets, they only get salted hashes, not plaintext passwords.

## 3. Authorization — Access Control Lists (ACLs)

Once a user is authenticated, Kafka checks **ACLs** to determine what the user can do.

ACLs define permissions for:

- Topics (read, write, delete)
- Consumer groups
- Cluster operations

They are stored in **Zookeeper** (for Kafka + ZK setups).

Example:

```bash
User:admin → can Write to topic secure-test
User:admin → can Read from topic secure-test
```

If a user attempts to perform an action not explicitly allowed by ACLs, Kafka denies it.

## 4. Role of Zookeeper in Security

In the **Kafka + Zookeeper** architecture:

- Zookeeper stores **SCRAM credentials**, **ACLs**, and **metadata**.
- Kafka brokers communicate with Zookeeper to verify authentication and authorization data.

> In Kafka’s newer **KRaft (Kafka Raft)** mode, these responsibilities move from Zookeeper into Kafka’s internal metadata quorum.

## 5. Full Flow — Client Connecting to a Secured Kafka Broker

The diagram below illustrates the step-by-step sequence of what happens when a **Kafka client connects securely** to a **Kafka broker** that uses **Zookeeper** for credential and ACL storage.

### Mermaid Sequence Diagram

```mermaid
sequenceDiagram
    participant C as Kafka Client
    participant B as Kafka Broker
    participant Z as Zookeeper

    Note over C,B: Step 1 - TLS Handshake (Encryption)
    C->>B: Connect to broker (SASL_SSL://broker1:9093)
    B-->>C: Sends broker certificate (signed by CA)
    C-->>B: Verifies CA and hostname
    Note over C,B: Secure TLS channel established

    Note over C,B: Step 2 - SASL/SCRAM Authentication
    C->>B: Sends username "admin"
    B->>Z: Fetch stored SCRAM hash for user
    Z-->>B: Returns stored salted hash
    B-->>C: Sends challenge (salt, nonce, iterations)
    C-->>B: Responds with computed client proof
    B-->>Z: Validates proof using stored hash
    Z-->>B: Authentication successful
    B-->>C: Authentication success (User=admin)

    Note over C,B,Z: Step 3 - Authorization
    C->>B: Produce message to topic "secure-test"
    B->>Z: Check ACL for User=admin on topic=secure-test
    Z-->>B: Allow (Write permission)
    B-->>C: Message accepted and stored

    Note over C,B: Step 4 - Encrypted Communication
    C-->>B: Send more data (encrypted under TLS)
    B-->>C: Send acknowledgments (encrypted under TLS)
```

## 6. Putting It All Together

| Stage                         | Description                         | Verified By                                 |
| ----------------------------- | ----------------------------------- | ------------------------------------------- |
| **TLS Handshake**             | Establishes an encrypted channel    | `openssl s_client`                          |
| **SASL/SCRAM Authentication** | Verifies client credentials         | Broker logs show “Authentication succeeded” |
| **Authorization (ACL Check)** | Verifies permissions for operations | `kafka-acls.sh --list`                      |
| **Data Exchange**             | All messages are encrypted          | Verified by no readable traffic on network  |

## 7. Why This Matters

| Concern             | Without Security                     | With TLS + SASL + ACL                                   |
| ------------------- | ------------------------------------ | ------------------------------------------------------- |
| **Confidentiality** | Anyone can sniff network traffic.    | Messages are encrypted.                                 |
| **Integrity**       | Messages can be modified in transit. | TLS ensures integrity via message authentication codes. |
| **Authentication**  | Anyone can connect.                  | Only known users (like `admin`) can connect.            |
| **Authorization**   | Any user can read/write any topic.   | Only authorized users can perform allowed actions.      |

## 8. Summary

- **TLS (Transport Layer Security)** encrypts communication between clients and brokers.
- **SASL/SCRAM-SHA-512 (Simple Authentication and Security Layer / Salted Challenge Response Authentication Mechanism)** securely authenticates users without sending plaintext passwords.
- **ACLs (Access Control Lists)** define and enforce permissions on Kafka resources.
- **Zookeeper** stores credentials and ACLs when using the legacy Kafka architecture.

Together, these components form a **defense-in-depth security model** for Apache Kafka.
